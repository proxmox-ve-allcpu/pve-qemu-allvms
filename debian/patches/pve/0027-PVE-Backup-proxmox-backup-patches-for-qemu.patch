From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dietmar Maurer <dietmar@proxmox.com>
Date: Mon, 6 Apr 2020 12:16:59 +0200
Subject: [PATCH] PVE-Backup: proxmox backup patches for qemu

Signed-off-by: Dietmar Maurer <dietmar@proxmox.com>
[PVE-Backup: avoid coroutines to fix AIO freeze, cleanups]
Signed-off-by: Stefan Reiter <s.reiter@proxmox.com>
Signed-off-by: Thomas Lamprecht <t.lamprecht@proxmox.com>
[add new force parameter to job_cancel_sync calls]
Signed-off-by: Fabian Ebner <f.ebner@proxmox.com>
---
 block/meson.build              |   5 +
 block/monitor/block-hmp-cmds.c |  33 ++
 blockdev.c                     |   1 +
 hmp-commands-info.hx           |  14 +
 hmp-commands.hx                |  29 +
 include/block/block_int.h      |   2 +-
 include/monitor/hmp.h          |   3 +
 meson.build                    |   1 +
 monitor/hmp-cmds.c             |  44 ++
 proxmox-backup-client.c        | 176 ++++++
 proxmox-backup-client.h        |  59 ++
 pve-backup.c                   | 959 +++++++++++++++++++++++++++++++++
 qapi/block-core.json           | 109 ++++
 qapi/common.json               |  13 +
 qapi/machine.json              |  15 +-
 15 files changed, 1449 insertions(+), 14 deletions(-)
 create mode 100644 proxmox-backup-client.c
 create mode 100644 proxmox-backup-client.h
 create mode 100644 pve-backup.c

diff --git a/block/meson.build b/block/meson.build
index 7883df047c..9d3dd5b7c3 100644
--- a/block/meson.build
+++ b/block/meson.build
@@ -46,6 +46,11 @@ block_ss.add(files(
 ), zstd, zlib, gnutls)
 
 block_ss.add(files('../vma-writer.c'), libuuid)
+block_ss.add(files(
+  '../proxmox-backup-client.c',
+  '../pve-backup.c',
+), libproxmox_backup_qemu)
+
 
 softmmu_ss.add(when: 'CONFIG_TCG', if_true: files('blkreplay.c'))
 
diff --git a/block/monitor/block-hmp-cmds.c b/block/monitor/block-hmp-cmds.c
index 2ac4aedfff..f6668ab01d 100644
--- a/block/monitor/block-hmp-cmds.c
+++ b/block/monitor/block-hmp-cmds.c
@@ -1015,3 +1015,36 @@ void hmp_info_snapshots(Monitor *mon, const QDict *qdict)
     g_free(sn_tab);
     g_free(global_snapshots);
 }
+
+void hmp_backup_cancel(Monitor *mon, const QDict *qdict)
+{
+    Error *error = NULL;
+
+    qmp_backup_cancel(&error);
+
+    hmp_handle_error(mon, error);
+}
+
+void hmp_backup(Monitor *mon, const QDict *qdict)
+{
+    Error *error = NULL;
+
+    int dir = qdict_get_try_bool(qdict, "directory", 0);
+    const char *backup_file = qdict_get_str(qdict, "backupfile");
+    const char *devlist = qdict_get_try_str(qdict, "devlist");
+    int64_t speed = qdict_get_try_int(qdict, "speed", 0);
+
+    qmp_backup(
+        backup_file,
+        false, NULL, // PBS password
+        false, NULL, // PBS keyfile
+        false, NULL, // PBS key_password
+        false, NULL, // PBS fingerprint
+        false, NULL, // PBS backup-id
+        false, 0, // PBS backup-time
+        true, dir ? BACKUP_FORMAT_DIR : BACKUP_FORMAT_VMA,
+        false, NULL, false, NULL, !!devlist,
+        devlist, qdict_haskey(qdict, "speed"), speed, &error);
+
+    hmp_handle_error(mon, error);
+}
diff --git a/blockdev.c b/blockdev.c
index 4be0863050..29fee73cbd 100644
--- a/blockdev.c
+++ b/blockdev.c
@@ -36,6 +36,7 @@
 #include "hw/block/block.h"
 #include "block/blockjob.h"
 #include "block/qdict.h"
+#include "block/blockjob_int.h"
 #include "block/throttle-groups.h"
 #include "monitor/monitor.h"
 #include "qemu/error-report.h"
diff --git a/hmp-commands-info.hx b/hmp-commands-info.hx
index 245f8acc55..3e7f2421eb 100644
--- a/hmp-commands-info.hx
+++ b/hmp-commands-info.hx
@@ -482,6 +482,20 @@ SRST
     Show the current VM UUID.
 ERST
 
+
+    {
+        .name       = "backup",
+        .args_type  = "",
+        .params     = "",
+        .help       = "show backup status",
+        .cmd        = hmp_info_backup,
+    },
+
+SRST
+  ``info backup``
+    Show backup status.
+ERST
+
 #if defined(CONFIG_SLIRP)
     {
         .name       = "usernet",
diff --git a/hmp-commands.hx b/hmp-commands.hx
index 1ad13b668b..d4bb00216e 100644
--- a/hmp-commands.hx
+++ b/hmp-commands.hx
@@ -99,6 +99,35 @@ ERST
 SRST
 ``block_stream``
   Copy data from a backing file into a block device.
+ERST
+
+   {
+        .name       = "backup",
+        .args_type  = "directory:-d,backupfile:s,speed:o?,devlist:s?",
+        .params     = "[-d] backupfile [speed [devlist]]",
+        .help       = "create a VM Backup."
+		    "\n\t\t\t Use -d to dump data into a directory instead"
+		    "\n\t\t\t of using VMA format.",
+        .cmd = hmp_backup,
+    },
+
+SRST
+``backup``
+  Create a VM backup.
+ERST
+
+    {
+        .name       = "backup_cancel",
+        .args_type  = "",
+        .params     = "",
+        .help       = "cancel the current VM backup",
+        .cmd        = hmp_backup_cancel,
+    },
+
+SRST
+``backup_cancel``
+  Cancel the current VM backup.
+
 ERST
 
     {
diff --git a/include/block/block_int.h b/include/block/block_int.h
index 1574b5564b..77076d7be3 100644
--- a/include/block/block_int.h
+++ b/include/block/block_int.h
@@ -67,7 +67,7 @@
 
 typedef int BackupDumpFunc(void *opaque, uint64_t offset, uint64_t bytes, const void *buf);
 
-BlockDriverState *bdrv_backuo_dump_create(
+BlockDriverState *bdrv_backup_dump_create(
     int dump_cb_block_size,
     uint64_t byte_size,
     BackupDumpFunc *dump_cb,
diff --git a/include/monitor/hmp.h b/include/monitor/hmp.h
index 3a39ba41b5..d269b4c99c 100644
--- a/include/monitor/hmp.h
+++ b/include/monitor/hmp.h
@@ -30,6 +30,7 @@ void hmp_info_savevm(Monitor *mon, const QDict *qdict);
 void hmp_info_migrate(Monitor *mon, const QDict *qdict);
 void hmp_info_migrate_capabilities(Monitor *mon, const QDict *qdict);
 void hmp_info_migrate_parameters(Monitor *mon, const QDict *qdict);
+void hmp_info_backup(Monitor *mon, const QDict *qdict);
 void hmp_info_cpus(Monitor *mon, const QDict *qdict);
 void hmp_info_vnc(Monitor *mon, const QDict *qdict);
 void hmp_info_spice(Monitor *mon, const QDict *qdict);
@@ -73,6 +74,8 @@ void hmp_x_colo_lost_heartbeat(Monitor *mon, const QDict *qdict);
 void hmp_set_password(Monitor *mon, const QDict *qdict);
 void hmp_expire_password(Monitor *mon, const QDict *qdict);
 void hmp_change(Monitor *mon, const QDict *qdict);
+void hmp_backup(Monitor *mon, const QDict *qdict);
+void hmp_backup_cancel(Monitor *mon, const QDict *qdict);
 void hmp_migrate(Monitor *mon, const QDict *qdict);
 void hmp_device_add(Monitor *mon, const QDict *qdict);
 void hmp_device_del(Monitor *mon, const QDict *qdict);
diff --git a/meson.build b/meson.build
index 54c23b9567..37dab249cc 100644
--- a/meson.build
+++ b/meson.build
@@ -1203,6 +1203,7 @@ keyutils = dependency('libkeyutils', required: false,
 has_gettid = cc.has_function('gettid')
 
 libuuid = cc.find_library('uuid', required: true)
+libproxmox_backup_qemu = cc.find_library('proxmox_backup_qemu', required: true)
 
 # libselinux
 selinux = dependency('libselinux',
diff --git a/monitor/hmp-cmds.c b/monitor/hmp-cmds.c
index 5000ce39d1..b2687eae3a 100644
--- a/monitor/hmp-cmds.c
+++ b/monitor/hmp-cmds.c
@@ -195,6 +195,50 @@ void hmp_info_mice(Monitor *mon, const QDict *qdict)
     qapi_free_MouseInfoList(mice_list);
 }
 
+void hmp_info_backup(Monitor *mon, const QDict *qdict)
+{
+    BackupStatus *info;
+
+    info = qmp_query_backup(NULL);
+
+    if (!info) {
+       monitor_printf(mon, "Backup status: not initialized\n");
+       return;
+    }
+
+    if (info->has_status) {
+        if (info->has_errmsg) {
+            monitor_printf(mon, "Backup status: %s - %s\n",
+                           info->status, info->errmsg);
+        } else {
+            monitor_printf(mon, "Backup status: %s\n", info->status);
+        }
+    }
+
+    if (info->has_backup_file) {
+        monitor_printf(mon, "Start time: %s", ctime(&info->start_time));
+        if (info->end_time) {
+            monitor_printf(mon, "End time: %s", ctime(&info->end_time));
+        }
+
+        int per = (info->has_total && info->total &&
+            info->has_transferred && info->transferred) ?
+            (info->transferred * 100)/info->total : 0;
+        int zero_per = (info->has_total && info->total &&
+                        info->has_zero_bytes && info->zero_bytes) ?
+            (info->zero_bytes * 100)/info->total : 0;
+        monitor_printf(mon, "Backup file: %s\n", info->backup_file);
+        monitor_printf(mon, "Backup uuid: %s\n", info->uuid);
+        monitor_printf(mon, "Total size: %zd\n", info->total);
+        monitor_printf(mon, "Transferred bytes: %zd (%d%%)\n",
+                       info->transferred, per);
+        monitor_printf(mon, "Zero bytes: %zd (%d%%)\n",
+                       info->zero_bytes, zero_per);
+    }
+
+    qapi_free_BackupStatus(info);
+}
+
 static char *SocketAddress_to_str(SocketAddress *addr)
 {
     switch (addr->type) {
diff --git a/proxmox-backup-client.c b/proxmox-backup-client.c
new file mode 100644
index 0000000000..a8f6653a81
--- /dev/null
+++ b/proxmox-backup-client.c
@@ -0,0 +1,176 @@
+#include "proxmox-backup-client.h"
+#include "qemu/main-loop.h"
+#include "block/aio-wait.h"
+#include "qapi/error.h"
+
+/* Proxmox Backup Server client bindings using coroutines */
+
+typedef struct BlockOnCoroutineWrapper {
+    AioContext *ctx;
+    CoroutineEntry *entry;
+    void *entry_arg;
+    bool finished;
+} BlockOnCoroutineWrapper;
+
+static void coroutine_fn block_on_coroutine_wrapper(void *opaque)
+{
+    BlockOnCoroutineWrapper *wrapper = opaque;
+    wrapper->entry(wrapper->entry_arg);
+    wrapper->finished = true;
+    aio_wait_kick();
+}
+
+void block_on_coroutine_fn(CoroutineEntry *entry, void *entry_arg)
+{
+    assert(!qemu_in_coroutine());
+
+    AioContext *ctx = qemu_get_current_aio_context();
+    BlockOnCoroutineWrapper wrapper = {
+        .finished = false,
+        .entry = entry,
+        .entry_arg = entry_arg,
+        .ctx = ctx,
+    };
+    Coroutine *wrapper_co = qemu_coroutine_create(block_on_coroutine_wrapper, &wrapper);
+    aio_co_enter(ctx, wrapper_co);
+    AIO_WAIT_WHILE(ctx, !wrapper.finished);
+}
+
+// This is called from another thread, so we use aio_co_schedule()
+static void proxmox_backup_schedule_wake(void *data) {
+    CoCtxData *waker = (CoCtxData *)data;
+    aio_co_schedule(waker->ctx, waker->co);
+}
+
+int coroutine_fn
+proxmox_backup_co_connect(ProxmoxBackupHandle *pbs, Error **errp)
+{
+    Coroutine *co = qemu_coroutine_self();
+    AioContext *ctx = qemu_get_current_aio_context();
+    CoCtxData waker = { .co = co, .ctx = ctx };
+    char *pbs_err = NULL;
+    int pbs_res = -1;
+
+    proxmox_backup_connect_async(pbs, proxmox_backup_schedule_wake, &waker, &pbs_res, &pbs_err);
+    qemu_coroutine_yield();
+    if (pbs_res < 0) {
+        if (errp) error_setg(errp, "backup connect failed: %s", pbs_err ? pbs_err : "unknown error");
+        if (pbs_err) proxmox_backup_free_error(pbs_err);
+    }
+    return pbs_res;
+}
+
+int coroutine_fn
+proxmox_backup_co_add_config(
+    ProxmoxBackupHandle *pbs,
+    const char *name,
+    const uint8_t *data,
+    uint64_t size,
+    Error **errp)
+{
+    Coroutine *co = qemu_coroutine_self();
+    AioContext *ctx = qemu_get_current_aio_context();
+    CoCtxData waker = { .co = co, .ctx = ctx };
+    char *pbs_err = NULL;
+    int pbs_res = -1;
+
+    proxmox_backup_add_config_async(
+        pbs, name, data, size ,proxmox_backup_schedule_wake, &waker, &pbs_res, &pbs_err);
+    qemu_coroutine_yield();
+    if (pbs_res < 0) {
+        if (errp) error_setg(errp, "backup add_config %s failed: %s", name, pbs_err ? pbs_err : "unknown error");
+        if (pbs_err) proxmox_backup_free_error(pbs_err);
+    }
+    return pbs_res;
+}
+
+int coroutine_fn
+proxmox_backup_co_register_image(
+    ProxmoxBackupHandle *pbs,
+    const char *device_name,
+    uint64_t size,
+    Error **errp)
+{
+    Coroutine *co = qemu_coroutine_self();
+    AioContext *ctx = qemu_get_current_aio_context();
+    CoCtxData waker = { .co = co, .ctx = ctx };
+    char *pbs_err = NULL;
+    int pbs_res = -1;
+
+    proxmox_backup_register_image_async(
+        pbs, device_name, size ,proxmox_backup_schedule_wake, &waker, &pbs_res, &pbs_err);
+    qemu_coroutine_yield();
+    if (pbs_res < 0) {
+        if (errp) error_setg(errp, "backup register image failed: %s", pbs_err ? pbs_err : "unknown error");
+        if (pbs_err) proxmox_backup_free_error(pbs_err);
+    }
+    return pbs_res;
+}
+
+int coroutine_fn
+proxmox_backup_co_finish(
+    ProxmoxBackupHandle *pbs,
+    Error **errp)
+{
+    Coroutine *co = qemu_coroutine_self();
+    AioContext *ctx = qemu_get_current_aio_context();
+    CoCtxData waker = { .co = co, .ctx = ctx };
+    char *pbs_err = NULL;
+    int pbs_res = -1;
+
+    proxmox_backup_finish_async(
+        pbs, proxmox_backup_schedule_wake, &waker, &pbs_res, &pbs_err);
+    qemu_coroutine_yield();
+    if (pbs_res < 0) {
+        if (errp) error_setg(errp, "backup finish failed: %s", pbs_err ? pbs_err : "unknown error");
+        if (pbs_err) proxmox_backup_free_error(pbs_err);
+    }
+    return pbs_res;
+}
+
+int coroutine_fn
+proxmox_backup_co_close_image(
+    ProxmoxBackupHandle *pbs,
+    uint8_t dev_id,
+    Error **errp)
+{
+    Coroutine *co = qemu_coroutine_self();
+    AioContext *ctx = qemu_get_current_aio_context();
+    CoCtxData waker = { .co = co, .ctx = ctx };
+    char *pbs_err = NULL;
+    int pbs_res = -1;
+
+    proxmox_backup_close_image_async(
+        pbs, dev_id, proxmox_backup_schedule_wake, &waker, &pbs_res, &pbs_err);
+    qemu_coroutine_yield();
+    if (pbs_res < 0) {
+        if (errp) error_setg(errp, "backup close image failed: %s", pbs_err ? pbs_err : "unknown error");
+        if (pbs_err) proxmox_backup_free_error(pbs_err);
+    }
+    return pbs_res;
+}
+
+int coroutine_fn
+proxmox_backup_co_write_data(
+    ProxmoxBackupHandle *pbs,
+    uint8_t dev_id,
+    const uint8_t *data,
+    uint64_t offset,
+    uint64_t size,
+    Error **errp)
+{
+    Coroutine *co = qemu_coroutine_self();
+    AioContext *ctx = qemu_get_current_aio_context();
+    CoCtxData waker = { .co = co, .ctx = ctx };
+    char *pbs_err = NULL;
+    int pbs_res = -1;
+
+    proxmox_backup_write_data_async(
+        pbs, dev_id, data, offset, size, proxmox_backup_schedule_wake, &waker, &pbs_res, &pbs_err);
+    qemu_coroutine_yield();
+    if (pbs_res < 0) {
+        if (errp) error_setg(errp, "backup write data failed: %s", pbs_err ? pbs_err : "unknown error");
+        if (pbs_err) proxmox_backup_free_error(pbs_err);
+    }
+    return pbs_res;
+}
diff --git a/proxmox-backup-client.h b/proxmox-backup-client.h
new file mode 100644
index 0000000000..1dda8b7d8f
--- /dev/null
+++ b/proxmox-backup-client.h
@@ -0,0 +1,59 @@
+#ifndef PROXMOX_BACKUP_CLIENT_H
+#define PROXMOX_BACKUP_CLIENT_H
+
+#include "qemu/osdep.h"
+#include "qemu/coroutine.h"
+#include "proxmox-backup-qemu.h"
+
+typedef struct CoCtxData {
+    Coroutine *co;
+    AioContext *ctx;
+    void *data;
+} CoCtxData;
+
+// FIXME: Remove once coroutines are supported for QMP
+void block_on_coroutine_fn(CoroutineEntry *entry, void *entry_arg);
+
+int coroutine_fn
+proxmox_backup_co_connect(
+    ProxmoxBackupHandle *pbs,
+    Error **errp);
+
+int coroutine_fn
+proxmox_backup_co_add_config(
+    ProxmoxBackupHandle *pbs,
+    const char *name,
+    const uint8_t *data,
+    uint64_t size,
+    Error **errp);
+
+int coroutine_fn
+proxmox_backup_co_register_image(
+    ProxmoxBackupHandle *pbs,
+    const char *device_name,
+    uint64_t size,
+    Error **errp);
+
+
+int coroutine_fn
+proxmox_backup_co_finish(
+    ProxmoxBackupHandle *pbs,
+    Error **errp);
+
+int coroutine_fn
+proxmox_backup_co_close_image(
+    ProxmoxBackupHandle *pbs,
+    uint8_t dev_id,
+    Error **errp);
+
+int coroutine_fn
+proxmox_backup_co_write_data(
+    ProxmoxBackupHandle *pbs,
+    uint8_t dev_id,
+    const uint8_t *data,
+    uint64_t offset,
+    uint64_t size,
+    Error **errp);
+
+
+#endif /* PROXMOX_BACKUP_CLIENT_H */
diff --git a/pve-backup.c b/pve-backup.c
new file mode 100644
index 0000000000..88f5ee133f
--- /dev/null
+++ b/pve-backup.c
@@ -0,0 +1,959 @@
+#include "proxmox-backup-client.h"
+#include "vma.h"
+
+#include "qemu/osdep.h"
+#include "qemu/module.h"
+#include "sysemu/block-backend.h"
+#include "sysemu/blockdev.h"
+#include "block/blockjob.h"
+#include "qapi/qapi-commands-block.h"
+#include "qapi/qmp/qerror.h"
+
+/* PVE backup state and related function */
+
+/*
+ * Note: A resume from a qemu_coroutine_yield can happen in a different thread,
+ * so you may not use normal mutexes within coroutines:
+ *
+ * ---bad-example---
+ * qemu_rec_mutex_lock(lock)
+ * ...
+ * qemu_coroutine_yield() // wait for something
+ * // we are now inside a different thread
+ * qemu_rec_mutex_unlock(lock) // Crash - wrong thread!!
+ * ---end-bad-example--
+ *
+ * ==> Always use CoMutext inside coroutines.
+ * ==> Never acquire/release AioContext withing coroutines (because that use QemuRecMutex)
+ *
+ */
+
+static struct PVEBackupState {
+    struct {
+        // Everithing accessed from qmp_backup_query command is protected using lock
+        QemuMutex lock;
+        Error *error;
+        time_t start_time;
+        time_t end_time;
+        char *backup_file;
+        uuid_t uuid;
+        char uuid_str[37];
+        size_t total;
+        size_t transferred;
+        size_t zero_bytes;
+    } stat;
+    int64_t speed;
+    VmaWriter *vmaw;
+    ProxmoxBackupHandle *pbs;
+    GList *di_list;
+    QemuMutex backup_mutex;
+    CoMutex dump_callback_mutex;
+} backup_state;
+
+static void pvebackup_init(void)
+{
+    qemu_mutex_init(&backup_state.stat.lock);
+    qemu_mutex_init(&backup_state.backup_mutex);
+    qemu_co_mutex_init(&backup_state.dump_callback_mutex);
+}
+
+// initialize PVEBackupState at startup
+opts_init(pvebackup_init);
+
+typedef struct PVEBackupDevInfo {
+    BlockDriverState *bs;
+    size_t size;
+    uint8_t dev_id;
+    bool completed;
+    char targetfile[PATH_MAX];
+    BlockDriverState *target;
+} PVEBackupDevInfo;
+
+static void pvebackup_run_next_job(void);
+
+static BlockJob *
+lookup_active_block_job(PVEBackupDevInfo *di)
+{
+    if (!di->completed && di->bs) {
+        for (BlockJob *job = block_job_next(NULL); job; job = block_job_next(job)) {
+            if (job->job.driver->job_type != JOB_TYPE_BACKUP) {
+                continue;
+            }
+
+            BackupBlockJob *bjob = container_of(job, BackupBlockJob, common);
+            if (bjob && bjob->source_bs == di->bs) {
+                return job;
+            }
+        }
+    }
+    return NULL;
+}
+
+static void pvebackup_propagate_error(Error *err)
+{
+    qemu_mutex_lock(&backup_state.stat.lock);
+    error_propagate(&backup_state.stat.error, err);
+    qemu_mutex_unlock(&backup_state.stat.lock);
+}
+
+static bool pvebackup_error_or_canceled(void)
+{
+    qemu_mutex_lock(&backup_state.stat.lock);
+    bool error_or_canceled = !!backup_state.stat.error;
+    qemu_mutex_unlock(&backup_state.stat.lock);
+
+    return error_or_canceled;
+}
+
+static void pvebackup_add_transfered_bytes(size_t transferred, size_t zero_bytes)
+{
+    qemu_mutex_lock(&backup_state.stat.lock);
+    backup_state.stat.zero_bytes += zero_bytes;
+    backup_state.stat.transferred += transferred;
+    qemu_mutex_unlock(&backup_state.stat.lock);
+}
+
+// This may get called from multiple coroutines in multiple io-threads
+// Note1: this may get called after job_cancel()
+static int coroutine_fn
+pvebackup_co_dump_pbs_cb(
+    void *opaque,
+    uint64_t start,
+    uint64_t bytes,
+    const void *pbuf)
+{
+    assert(qemu_in_coroutine());
+
+    const uint64_t size = bytes;
+    const unsigned char *buf = pbuf;
+    PVEBackupDevInfo *di = opaque;
+
+    assert(backup_state.pbs);
+
+    Error *local_err = NULL;
+    int pbs_res = -1;
+
+    qemu_co_mutex_lock(&backup_state.dump_callback_mutex);
+
+    // avoid deadlock if job is cancelled
+    if (pvebackup_error_or_canceled()) {
+        qemu_co_mutex_unlock(&backup_state.dump_callback_mutex);
+        return -1;
+    }
+
+    pbs_res = proxmox_backup_co_write_data(backup_state.pbs, di->dev_id, buf, start, size, &local_err);
+    qemu_co_mutex_unlock(&backup_state.dump_callback_mutex);
+
+    if (pbs_res < 0) {
+        pvebackup_propagate_error(local_err);
+        return pbs_res;
+    } else {
+        pvebackup_add_transfered_bytes(size, !buf ? size : 0);
+    }
+
+    return size;
+}
+
+// This may get called from multiple coroutines in multiple io-threads
+static int coroutine_fn
+pvebackup_co_dump_vma_cb(
+    void *opaque,
+    uint64_t start,
+    uint64_t bytes,
+    const void *pbuf)
+{
+    assert(qemu_in_coroutine());
+
+    const uint64_t size = bytes;
+    const unsigned char *buf = pbuf;
+    PVEBackupDevInfo *di = opaque;
+
+    int ret = -1;
+
+    assert(backup_state.vmaw);
+
+    uint64_t remaining = size;
+
+    uint64_t cluster_num = start / VMA_CLUSTER_SIZE;
+    if ((cluster_num * VMA_CLUSTER_SIZE) != start) {
+        Error *local_err = NULL;
+        error_setg(&local_err,
+                   "got unaligned write inside backup dump "
+                   "callback (sector %ld)", start);
+        pvebackup_propagate_error(local_err);
+        return -1; // not aligned to cluster size
+    }
+
+    while (remaining > 0) {
+        qemu_co_mutex_lock(&backup_state.dump_callback_mutex);
+        // avoid deadlock if job is cancelled
+        if (pvebackup_error_or_canceled()) {
+            qemu_co_mutex_unlock(&backup_state.dump_callback_mutex);
+            return -1;
+        }
+
+        size_t zero_bytes = 0;
+        ret = vma_writer_write(backup_state.vmaw, di->dev_id, cluster_num, buf, &zero_bytes);
+        qemu_co_mutex_unlock(&backup_state.dump_callback_mutex);
+
+        ++cluster_num;
+        if (buf) {
+            buf += VMA_CLUSTER_SIZE;
+        }
+        if (ret < 0) {
+            Error *local_err = NULL;
+            vma_writer_error_propagate(backup_state.vmaw, &local_err);
+            pvebackup_propagate_error(local_err);
+            return ret;
+        } else {
+            if (remaining >= VMA_CLUSTER_SIZE) {
+                assert(ret == VMA_CLUSTER_SIZE);
+                pvebackup_add_transfered_bytes(VMA_CLUSTER_SIZE, zero_bytes);
+                remaining -= VMA_CLUSTER_SIZE;
+            } else {
+                assert(ret == remaining);
+                pvebackup_add_transfered_bytes(remaining, zero_bytes);
+                remaining = 0;
+            }
+        }
+    }
+
+    return size;
+}
+
+// assumes the caller holds backup_mutex
+static void coroutine_fn pvebackup_co_cleanup(void *unused)
+{
+    assert(qemu_in_coroutine());
+
+    qemu_mutex_lock(&backup_state.stat.lock);
+    backup_state.stat.end_time = time(NULL);
+    qemu_mutex_unlock(&backup_state.stat.lock);
+
+    if (backup_state.vmaw) {
+        Error *local_err = NULL;
+        vma_writer_close(backup_state.vmaw, &local_err);
+
+        if (local_err != NULL) {
+            pvebackup_propagate_error(local_err);
+         }
+
+        backup_state.vmaw = NULL;
+    }
+
+    if (backup_state.pbs) {
+        if (!pvebackup_error_or_canceled()) {
+            Error *local_err = NULL;
+            proxmox_backup_co_finish(backup_state.pbs, &local_err);
+            if (local_err != NULL) {
+                pvebackup_propagate_error(local_err);
+            }
+        }
+
+        proxmox_backup_disconnect(backup_state.pbs);
+        backup_state.pbs = NULL;
+    }
+
+    g_list_free(backup_state.di_list);
+    backup_state.di_list = NULL;
+}
+
+// assumes the caller holds backup_mutex
+static void coroutine_fn pvebackup_complete_stream(void *opaque)
+{
+    PVEBackupDevInfo *di = opaque;
+
+    bool error_or_canceled = pvebackup_error_or_canceled();
+
+    if (backup_state.vmaw) {
+        vma_writer_close_stream(backup_state.vmaw, di->dev_id);
+    }
+
+    if (backup_state.pbs && !error_or_canceled) {
+        Error *local_err = NULL;
+        proxmox_backup_co_close_image(backup_state.pbs, di->dev_id, &local_err);
+        if (local_err != NULL) {
+            pvebackup_propagate_error(local_err);
+        }
+    }
+}
+
+static void pvebackup_complete_cb(void *opaque, int ret)
+{
+    assert(!qemu_in_coroutine());
+
+    PVEBackupDevInfo *di = opaque;
+
+    qemu_mutex_lock(&backup_state.backup_mutex);
+
+    di->completed = true;
+
+    if (ret < 0) {
+        Error *local_err = NULL;
+        error_setg(&local_err, "job failed with err %d - %s", ret, strerror(-ret));
+        pvebackup_propagate_error(local_err);
+    }
+
+    di->bs = NULL;
+
+    assert(di->target == NULL);
+
+    block_on_coroutine_fn(pvebackup_complete_stream, di);
+
+    // remove self from job queue
+    backup_state.di_list = g_list_remove(backup_state.di_list, di);
+
+    g_free(di);
+
+    qemu_mutex_unlock(&backup_state.backup_mutex);
+
+    pvebackup_run_next_job();
+}
+
+static void pvebackup_cancel(void)
+{
+    assert(!qemu_in_coroutine());
+
+    Error *cancel_err = NULL;
+    error_setg(&cancel_err, "backup canceled");
+    pvebackup_propagate_error(cancel_err);
+
+    qemu_mutex_lock(&backup_state.backup_mutex);
+
+    if (backup_state.vmaw) {
+        /* make sure vma writer does not block anymore */
+        vma_writer_set_error(backup_state.vmaw, "backup canceled");
+    }
+
+    if (backup_state.pbs) {
+        proxmox_backup_abort(backup_state.pbs, "backup canceled");
+    }
+
+    qemu_mutex_unlock(&backup_state.backup_mutex);
+
+    for(;;) {
+
+        BlockJob *next_job = NULL;
+
+        qemu_mutex_lock(&backup_state.backup_mutex);
+
+        GList *l = backup_state.di_list;
+        while (l) {
+            PVEBackupDevInfo *di = (PVEBackupDevInfo *)l->data;
+            l = g_list_next(l);
+
+            BlockJob *job = lookup_active_block_job(di);
+            if (job != NULL) {
+                next_job = job;
+                break;
+            }
+        }
+
+        qemu_mutex_unlock(&backup_state.backup_mutex);
+
+        if (next_job) {
+            AioContext *aio_context = next_job->job.aio_context;
+            aio_context_acquire(aio_context);
+            job_cancel_sync(&next_job->job, true);
+            aio_context_release(aio_context);
+        } else {
+            break;
+        }
+    }
+}
+
+void qmp_backup_cancel(Error **errp)
+{
+    pvebackup_cancel();
+}
+
+// assumes the caller holds backup_mutex
+static int coroutine_fn pvebackup_co_add_config(
+    const char *file,
+    const char *name,
+    BackupFormat format,
+    const char *backup_dir,
+    VmaWriter *vmaw,
+    ProxmoxBackupHandle *pbs,
+    Error **errp)
+{
+    int res = 0;
+
+    char *cdata = NULL;
+    gsize clen = 0;
+    GError *err = NULL;
+    if (!g_file_get_contents(file, &cdata, &clen, &err)) {
+        error_setg(errp, "unable to read file '%s'", file);
+        return 1;
+    }
+
+    char *basename = g_path_get_basename(file);
+    if (name == NULL) name = basename;
+
+    if (format == BACKUP_FORMAT_VMA) {
+        if (vma_writer_add_config(vmaw, name, cdata, clen) != 0) {
+            error_setg(errp, "unable to add %s config data to vma archive", file);
+            goto err;
+        }
+    } else if (format == BACKUP_FORMAT_PBS) {
+        if (proxmox_backup_co_add_config(pbs, name, (unsigned char *)cdata, clen, errp) < 0)
+            goto err;
+    } else if (format == BACKUP_FORMAT_DIR) {
+        char config_path[PATH_MAX];
+        snprintf(config_path, PATH_MAX, "%s/%s", backup_dir, name);
+        if (!g_file_set_contents(config_path, cdata, clen, &err)) {
+            error_setg(errp, "unable to write config file '%s'", config_path);
+            goto err;
+        }
+    }
+
+ out:
+    g_free(basename);
+    g_free(cdata);
+    return res;
+
+ err:
+    res = -1;
+    goto out;
+}
+
+bool job_should_pause(Job *job);
+
+static void pvebackup_run_next_job(void)
+{
+    assert(!qemu_in_coroutine());
+
+    qemu_mutex_lock(&backup_state.backup_mutex);
+
+    GList *l = backup_state.di_list;
+    while (l) {
+        PVEBackupDevInfo *di = (PVEBackupDevInfo *)l->data;
+        l = g_list_next(l);
+
+        BlockJob *job = lookup_active_block_job(di);
+
+        if (job) {
+            qemu_mutex_unlock(&backup_state.backup_mutex);
+
+            AioContext *aio_context = job->job.aio_context;
+            aio_context_acquire(aio_context);
+
+            if (job_should_pause(&job->job)) {
+                bool error_or_canceled = pvebackup_error_or_canceled();
+                if (error_or_canceled) {
+                    job_cancel_sync(&job->job, true);
+                } else {
+                    job_resume(&job->job);
+                }
+            }
+            aio_context_release(aio_context);
+            return;
+        }
+    }
+
+    block_on_coroutine_fn(pvebackup_co_cleanup, NULL); // no more jobs, run cleanup
+
+    qemu_mutex_unlock(&backup_state.backup_mutex);
+}
+
+static bool create_backup_jobs(void) {
+
+    assert(!qemu_in_coroutine());
+
+    Error *local_err = NULL;
+
+    BackupPerf perf = { .max_workers = 16 };
+
+    /* create and start all jobs (paused state) */
+    GList *l =  backup_state.di_list;
+    while (l) {
+        PVEBackupDevInfo *di = (PVEBackupDevInfo *)l->data;
+        l = g_list_next(l);
+
+        assert(di->target != NULL);
+
+        AioContext *aio_context = bdrv_get_aio_context(di->bs);
+        aio_context_acquire(aio_context);
+
+        BlockJob *job = backup_job_create(
+            NULL, di->bs, di->target, backup_state.speed, MIRROR_SYNC_MODE_FULL, NULL,
+            BITMAP_SYNC_MODE_NEVER, false, NULL, &perf, BLOCKDEV_ON_ERROR_REPORT, BLOCKDEV_ON_ERROR_REPORT,
+            JOB_DEFAULT, pvebackup_complete_cb, di, NULL, &local_err);
+
+        aio_context_release(aio_context);
+
+        if (!job || local_err != NULL) {
+            Error *create_job_err = NULL;
+            error_setg(&create_job_err, "backup_job_create failed: %s",
+                       local_err ? error_get_pretty(local_err) : "null");
+
+            pvebackup_propagate_error(create_job_err);
+            break;
+        }
+        job_start(&job->job);
+
+        bdrv_unref(di->target);
+        di->target = NULL;
+    }
+
+    bool errors = pvebackup_error_or_canceled();
+
+    if (errors) {
+        l = backup_state.di_list;
+        while (l) {
+            PVEBackupDevInfo *di = (PVEBackupDevInfo *)l->data;
+            l = g_list_next(l);
+
+            if (di->target) {
+                bdrv_unref(di->target);
+                di->target = NULL;
+            }
+        }
+    }
+
+    return errors;
+}
+
+typedef struct QmpBackupTask {
+    const char *backup_file;
+    bool has_password;
+    const char *password;
+    bool has_keyfile;
+    const char *keyfile;
+    bool has_key_password;
+    const char *key_password;
+    bool has_backup_id;
+    const char *backup_id;
+    bool has_backup_time;
+    const char *fingerprint;
+    bool has_fingerprint;
+    int64_t backup_time;
+    bool has_format;
+    BackupFormat format;
+    bool has_config_file;
+    const char *config_file;
+    bool has_firewall_file;
+    const char *firewall_file;
+    bool has_devlist;
+    const char *devlist;
+    bool has_speed;
+    int64_t speed;
+    Error **errp;
+    UuidInfo *result;
+} QmpBackupTask;
+
+// assumes the caller holds backup_mutex
+static void coroutine_fn pvebackup_co_prepare(void *opaque)
+{
+    assert(qemu_in_coroutine());
+
+    QmpBackupTask *task = opaque;
+
+    task->result = NULL; // just to be sure
+
+    BlockBackend *blk;
+    BlockDriverState *bs = NULL;
+    const char *backup_dir = NULL;
+    Error *local_err = NULL;
+    uuid_t uuid;
+    VmaWriter *vmaw = NULL;
+    ProxmoxBackupHandle *pbs = NULL;
+    gchar **devs = NULL;
+    GList *di_list = NULL;
+    GList *l;
+    UuidInfo *uuid_info;
+
+    const char *config_name = "qemu-server.conf";
+    const char *firewall_name = "qemu-server.fw";
+
+    if (backup_state.di_list) {
+         error_set(task->errp, ERROR_CLASS_GENERIC_ERROR,
+                  "previous backup not finished");
+        return;
+    }
+
+    /* Todo: try to auto-detect format based on file name */
+    BackupFormat format = task->has_format ? task->format : BACKUP_FORMAT_VMA;
+
+    if (task->has_devlist) {
+        devs = g_strsplit_set(task->devlist, ",;:", -1);
+
+        gchar **d = devs;
+        while (d && *d) {
+            blk = blk_by_name(*d);
+            if (blk) {
+                bs = blk_bs(blk);
+                if (!bdrv_is_inserted(bs)) {
+                    error_setg(task->errp, QERR_DEVICE_HAS_NO_MEDIUM, *d);
+                    goto err;
+                }
+                PVEBackupDevInfo *di = g_new0(PVEBackupDevInfo, 1);
+                di->bs = bs;
+                di_list = g_list_append(di_list, di);
+            } else {
+                error_set(task->errp, ERROR_CLASS_DEVICE_NOT_FOUND,
+                          "Device '%s' not found", *d);
+                goto err;
+            }
+            d++;
+        }
+
+    } else {
+        BdrvNextIterator it;
+
+        bs = NULL;
+        for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {
+            if (!bdrv_is_inserted(bs) || bdrv_is_read_only(bs)) {
+                continue;
+            }
+
+            PVEBackupDevInfo *di = g_new0(PVEBackupDevInfo, 1);
+            di->bs = bs;
+            di_list = g_list_append(di_list, di);
+        }
+    }
+
+    if (!di_list) {
+        error_set(task->errp, ERROR_CLASS_GENERIC_ERROR, "empty device list");
+        goto err;
+    }
+
+    size_t total = 0;
+
+    l = di_list;
+    while (l) {
+        PVEBackupDevInfo *di = (PVEBackupDevInfo *)l->data;
+        l = g_list_next(l);
+        if (bdrv_op_is_blocked(di->bs, BLOCK_OP_TYPE_BACKUP_SOURCE, task->errp)) {
+            goto err;
+        }
+
+        ssize_t size = bdrv_getlength(di->bs);
+        if (size < 0) {
+            error_setg_errno(task->errp, -di->size, "bdrv_getlength failed");
+            goto err;
+        }
+        di->size = size;
+        total += size;
+    }
+
+    uuid_generate(uuid);
+
+    if (format == BACKUP_FORMAT_PBS) {
+        if (!task->has_password) {
+            error_set(task->errp, ERROR_CLASS_GENERIC_ERROR, "missing parameter 'password'");
+            goto err;
+        }
+        if (!task->has_backup_id) {
+            error_set(task->errp, ERROR_CLASS_GENERIC_ERROR, "missing parameter 'backup-id'");
+            goto err;
+        }
+        if (!task->has_backup_time) {
+            error_set(task->errp, ERROR_CLASS_GENERIC_ERROR, "missing parameter 'backup-time'");
+            goto err;
+        }
+
+        int dump_cb_block_size = PROXMOX_BACKUP_DEFAULT_CHUNK_SIZE; // Hardcoded (4M)
+        firewall_name = "fw.conf";
+
+        char *pbs_err = NULL;
+        pbs = proxmox_backup_new(
+            task->backup_file,
+            task->backup_id,
+            task->backup_time,
+            dump_cb_block_size,
+            task->has_password ? task->password : NULL,
+            task->has_keyfile ? task->keyfile : NULL,
+            task->has_key_password ? task->key_password : NULL,
+            task->has_fingerprint ? task->fingerprint : NULL,
+            &pbs_err);
+
+        if (!pbs) {
+            error_set(task->errp, ERROR_CLASS_GENERIC_ERROR,
+                      "proxmox_backup_new failed: %s", pbs_err);
+            proxmox_backup_free_error(pbs_err);
+            goto err;
+        }
+
+        if (proxmox_backup_co_connect(pbs, task->errp) < 0)
+            goto err;
+
+        /* register all devices */
+        l = di_list;
+        while (l) {
+            PVEBackupDevInfo *di = (PVEBackupDevInfo *)l->data;
+            l = g_list_next(l);
+
+            const char *devname = bdrv_get_device_name(di->bs);
+
+            int dev_id = proxmox_backup_co_register_image(pbs, devname, di->size, task->errp);
+            if (dev_id < 0)
+                goto err;
+
+            if (!(di->target = bdrv_backup_dump_create(dump_cb_block_size, di->size, pvebackup_co_dump_pbs_cb, di, task->errp))) {
+                goto err;
+            }
+
+            di->dev_id = dev_id;
+        }
+    } else if (format == BACKUP_FORMAT_VMA) {
+        vmaw = vma_writer_create(task->backup_file, uuid, &local_err);
+        if (!vmaw) {
+            if (local_err) {
+                error_propagate(task->errp, local_err);
+            }
+            goto err;
+        }
+
+        /* register all devices for vma writer */
+        l = di_list;
+        while (l) {
+            PVEBackupDevInfo *di = (PVEBackupDevInfo *)l->data;
+            l = g_list_next(l);
+
+            if (!(di->target = bdrv_backup_dump_create(VMA_CLUSTER_SIZE, di->size, pvebackup_co_dump_vma_cb, di, task->errp))) {
+                goto err;
+            }
+
+            const char *devname = bdrv_get_device_name(di->bs);
+            di->dev_id = vma_writer_register_stream(vmaw, devname, di->size);
+            if (di->dev_id <= 0) {
+                error_set(task->errp, ERROR_CLASS_GENERIC_ERROR,
+                          "register_stream failed");
+                goto err;
+            }
+        }
+    } else if (format == BACKUP_FORMAT_DIR) {
+        if (mkdir(task->backup_file, 0640) != 0) {
+            error_setg_errno(task->errp, errno, "can't create directory '%s'\n",
+                             task->backup_file);
+            goto err;
+        }
+        backup_dir = task->backup_file;
+
+        l = di_list;
+        while (l) {
+            PVEBackupDevInfo *di = (PVEBackupDevInfo *)l->data;
+            l = g_list_next(l);
+
+            const char *devname = bdrv_get_device_name(di->bs);
+            snprintf(di->targetfile, PATH_MAX, "%s/%s.raw", backup_dir, devname);
+
+            int flags = BDRV_O_RDWR;
+            bdrv_img_create(di->targetfile, "raw", NULL, NULL, NULL,
+                            di->size, flags, false, &local_err);
+            if (local_err) {
+                error_propagate(task->errp, local_err);
+                goto err;
+            }
+
+            di->target = bdrv_open(di->targetfile, NULL, NULL, flags, &local_err);
+            if (!di->target) {
+                error_propagate(task->errp, local_err);
+                goto err;
+            }
+        }
+    } else {
+        error_set(task->errp, ERROR_CLASS_GENERIC_ERROR, "unknown backup format");
+        goto err;
+    }
+
+
+    /* add configuration file to archive */
+    if (task->has_config_file) {
+        if (pvebackup_co_add_config(task->config_file, config_name, format, backup_dir,
+                                    vmaw, pbs, task->errp) != 0) {
+            goto err;
+        }
+    }
+
+    /* add firewall file to archive */
+    if (task->has_firewall_file) {
+        if (pvebackup_co_add_config(task->firewall_file, firewall_name, format, backup_dir,
+                                    vmaw, pbs, task->errp) != 0) {
+            goto err;
+        }
+    }
+    /* initialize global backup_state now */
+
+    qemu_mutex_lock(&backup_state.stat.lock);
+
+    if (backup_state.stat.error) {
+        error_free(backup_state.stat.error);
+        backup_state.stat.error = NULL;
+    }
+
+    backup_state.stat.start_time = time(NULL);
+    backup_state.stat.end_time = 0;
+
+    if (backup_state.stat.backup_file) {
+        g_free(backup_state.stat.backup_file);
+    }
+    backup_state.stat.backup_file = g_strdup(task->backup_file);
+
+    uuid_copy(backup_state.stat.uuid, uuid);
+    uuid_unparse_lower(uuid, backup_state.stat.uuid_str);
+    char *uuid_str = g_strdup(backup_state.stat.uuid_str);
+
+    backup_state.stat.total = total;
+    backup_state.stat.transferred = 0;
+    backup_state.stat.zero_bytes = 0;
+
+    qemu_mutex_unlock(&backup_state.stat.lock);
+
+    backup_state.speed = (task->has_speed && task->speed > 0) ? task->speed : 0;
+
+    backup_state.vmaw = vmaw;
+    backup_state.pbs = pbs;
+
+    backup_state.di_list = di_list;
+
+    uuid_info = g_malloc0(sizeof(*uuid_info));
+    uuid_info->UUID = uuid_str;
+
+    task->result = uuid_info;
+    return;
+
+err:
+
+    l = di_list;
+    while (l) {
+        PVEBackupDevInfo *di = (PVEBackupDevInfo *)l->data;
+        l = g_list_next(l);
+
+        if (di->target) {
+            bdrv_unref(di->target);
+        }
+
+        if (di->targetfile[0]) {
+            unlink(di->targetfile);
+        }
+        g_free(di);
+    }
+    g_list_free(di_list);
+
+    if (devs) {
+        g_strfreev(devs);
+    }
+
+    if (vmaw) {
+        Error *err = NULL;
+        vma_writer_close(vmaw, &err);
+        unlink(task->backup_file);
+    }
+
+    if (pbs) {
+        proxmox_backup_disconnect(pbs);
+    }
+
+    if (backup_dir) {
+        rmdir(backup_dir);
+    }
+
+    task->result = NULL;
+    return;
+}
+
+UuidInfo *qmp_backup(
+    const char *backup_file,
+    bool has_password, const char *password,
+    bool has_keyfile, const char *keyfile,
+    bool has_key_password, const char *key_password,
+    bool has_fingerprint, const char *fingerprint,
+    bool has_backup_id, const char *backup_id,
+    bool has_backup_time, int64_t backup_time,
+    bool has_format, BackupFormat format,
+    bool has_config_file, const char *config_file,
+    bool has_firewall_file, const char *firewall_file,
+    bool has_devlist, const char *devlist,
+    bool has_speed, int64_t speed, Error **errp)
+{
+    QmpBackupTask task = {
+        .backup_file = backup_file,
+        .has_password = has_password,
+        .password = password,
+        .has_key_password = has_key_password,
+        .key_password = key_password,
+        .has_fingerprint = has_fingerprint,
+        .fingerprint = fingerprint,
+        .has_backup_id = has_backup_id,
+        .backup_id = backup_id,
+        .has_backup_time = has_backup_time,
+        .backup_time = backup_time,
+        .has_format = has_format,
+        .format = format,
+        .has_config_file = has_config_file,
+        .config_file = config_file,
+        .has_firewall_file = has_firewall_file,
+        .firewall_file = firewall_file,
+        .has_devlist = has_devlist,
+        .devlist = devlist,
+        .has_speed = has_speed,
+        .speed = speed,
+        .errp = errp,
+    };
+
+    qemu_mutex_lock(&backup_state.backup_mutex);
+
+    block_on_coroutine_fn(pvebackup_co_prepare, &task);
+
+    if (*errp == NULL) {
+        create_backup_jobs();
+        qemu_mutex_unlock(&backup_state.backup_mutex);
+        pvebackup_run_next_job();
+    } else {
+        qemu_mutex_unlock(&backup_state.backup_mutex);
+    }
+
+    return task.result;
+}
+
+BackupStatus *qmp_query_backup(Error **errp)
+{
+    BackupStatus *info = g_malloc0(sizeof(*info));
+
+    qemu_mutex_lock(&backup_state.stat.lock);
+
+    if (!backup_state.stat.start_time) {
+        /* not started, return {} */
+        qemu_mutex_unlock(&backup_state.stat.lock);
+        return info;
+    }
+
+    info->has_status = true;
+    info->has_start_time = true;
+    info->start_time = backup_state.stat.start_time;
+
+    if (backup_state.stat.backup_file) {
+        info->has_backup_file = true;
+        info->backup_file = g_strdup(backup_state.stat.backup_file);
+    }
+
+    info->has_uuid = true;
+    info->uuid = g_strdup(backup_state.stat.uuid_str);
+
+    if (backup_state.stat.end_time) {
+        if (backup_state.stat.error) {
+            info->status = g_strdup("error");
+            info->has_errmsg = true;
+            info->errmsg = g_strdup(error_get_pretty(backup_state.stat.error));
+        } else {
+            info->status = g_strdup("done");
+        }
+        info->has_end_time = true;
+        info->end_time = backup_state.stat.end_time;
+    } else {
+        info->status = g_strdup("active");
+    }
+
+    info->has_total = true;
+    info->total = backup_state.stat.total;
+    info->has_zero_bytes = true;
+    info->zero_bytes = backup_state.stat.zero_bytes;
+    info->has_transferred = true;
+    info->transferred = backup_state.stat.transferred;
+
+    qemu_mutex_unlock(&backup_state.stat.lock);
+
+    return info;
+}
diff --git a/qapi/block-core.json b/qapi/block-core.json
index cd69af921e..e4c3de0804 100644
--- a/qapi/block-core.json
+++ b/qapi/block-core.json
@@ -744,6 +744,115 @@
 { 'command': 'query-block', 'returns': ['BlockInfo'] }
 
 
+##
+# @BackupStatus:
+#
+# Detailed backup status.
+#
+# @status: string describing the current backup status.
+#          This can be 'active', 'done', 'error'. If this field is not
+#          returned, no backup process has been initiated
+#
+# @errmsg: error message (only returned if status is 'error')
+#
+# @total: total amount of bytes involved in the backup process
+#
+# @transferred: amount of bytes already backed up.
+#
+# @zero-bytes: amount of 'zero' bytes detected.
+#
+# @start-time: time (epoch) when backup job started.
+#
+# @end-time: time (epoch) when backup job finished.
+#
+# @backup-file: backup file name
+#
+# @uuid: uuid for this backup job
+#
+##
+{ 'struct': 'BackupStatus',
+  'data': {'*status': 'str', '*errmsg': 'str', '*total': 'int',
+           '*transferred': 'int', '*zero-bytes': 'int',
+           '*start-time': 'int', '*end-time': 'int',
+           '*backup-file': 'str', '*uuid': 'str' } }
+
+##
+# @BackupFormat:
+#
+# An enumeration of supported backup formats.
+#
+# @vma: Proxmox vma backup format
+##
+{ 'enum': 'BackupFormat',
+  'data': [ 'vma', 'dir', 'pbs' ] }
+
+##
+# @backup:
+#
+# Starts a VM backup.
+#
+# @backup-file: the backup file name
+#
+# @format: format of the backup file
+#
+# @config-file: a configuration file to include into
+#               the backup archive.
+#
+# @speed: the maximum speed, in bytes per second
+#
+# @devlist: list of block device names (separated by ',', ';'
+#           or ':'). By default the backup includes all writable block devices.
+#
+# @password: backup server passsword (required for format 'pbs')
+#
+# @keyfile: keyfile used for encryption (optional for format 'pbs')
+#
+# @key-password: password for keyfile (optional for format 'pbs')
+#
+# @fingerprint: server cert fingerprint (optional for format 'pbs')
+#
+# @backup-id: backup ID (required for format 'pbs')
+#
+# @backup-time: backup timestamp (Unix epoch, required for format 'pbs')
+#
+# Returns: the uuid of the backup job
+#
+##
+{ 'command': 'backup', 'data': { 'backup-file': 'str',
+                                    '*password': 'str',
+                                    '*keyfile': 'str',
+                                    '*key-password': 'str',
+                                    '*fingerprint': 'str',
+                                    '*backup-id': 'str',
+                                    '*backup-time': 'int',
+                                    '*format': 'BackupFormat',
+                                    '*config-file': 'str',
+                                    '*firewall-file': 'str',
+                                    '*devlist': 'str', '*speed': 'int' },
+  'returns': 'UuidInfo' }
+
+##
+# @query-backup:
+#
+# Returns information about current/last backup task.
+#
+# Returns: @BackupStatus
+#
+##
+{ 'command': 'query-backup', 'returns': 'BackupStatus' }
+
+##
+# @backup-cancel:
+#
+# Cancel the current executing backup process.
+#
+# Returns: nothing on success
+#
+# Notes: This command succeeds even if there is no backup process running.
+#
+##
+{ 'command': 'backup-cancel' }
+
 ##
 # @BlockDeviceTimedStats:
 #
diff --git a/qapi/common.json b/qapi/common.json
index 412cc4f5ae..3e7a77ea66 100644
--- a/qapi/common.json
+++ b/qapi/common.json
@@ -208,3 +208,16 @@
 ##
 { 'struct': 'HumanReadableText',
   'data': { 'human-readable-text': 'str' } }
+
+##
+# @UuidInfo:
+#
+# Guest UUID information (Universally Unique Identifier).
+#
+# @UUID: the UUID of the guest
+#
+# Since: 0.14.0
+#
+# Notes: If no UUID was specified for the guest, a null UUID is returned.
+##
+{ 'struct': 'UuidInfo', 'data': {'UUID': 'str'} }
diff --git a/qapi/machine.json b/qapi/machine.json
index a05c46e253..e2cec7922f 100644
--- a/qapi/machine.json
+++ b/qapi/machine.json
@@ -4,6 +4,8 @@
 # This work is licensed under the terms of the GNU GPL, version 2 or later.
 # See the COPYING file in the top-level directory.
 
+{ 'include': 'common.json' }
+
 ##
 # = Machines
 ##
@@ -229,19 +231,6 @@
 ##
 { 'command': 'query-target', 'returns': 'TargetInfo' }
 
-##
-# @UuidInfo:
-#
-# Guest UUID information (Universally Unique Identifier).
-#
-# @UUID: the UUID of the guest
-#
-# Since: 0.14
-#
-# Notes: If no UUID was specified for the guest, a null UUID is returned.
-##
-{ 'struct': 'UuidInfo', 'data': {'UUID': 'str'} }
-
 ##
 # @query-uuid:
 #
